#ifndef HEADER_H
#define HEADER_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct {
	char* ime;
	char* prezime;
	int id;
} CLAN;

// Validacija
int validirajImePrezime(const char* unos);
int validirajID(const char* unos);

// Dinamički rad s članovima
CLAN** ucitajClanoveIzDatoteke(FILE* file, int* brojClanova);
void spremiClanoveUDatoteku(FILE* file, CLAN** clanovi, int brojClanova);
void oslobodiClanove(CLAN** clanovi, int brojClanova);

// CRUD
void dodajClana(CLAN*** clanovi, int* brojClanova);
void izbrisiClana(CLAN*** clanovi, int* brojClanova, int id);
void ispisClanova(CLAN** clanovi, int brojClanova);
void ispisSortiranihClanovaPoImenu(CLAN** clanovi, int brojClanova);
void ispisSortiranihClanovaPoPrezimenu(CLAN** clanovi, int brojClanova);
void pretrazivanje(CLAN** clanovi, int brojClanova, int id);
void najveciID(CLAN** clanovi, int brojClanova);



funkcije.c 


#endif
#define _CRT_SECURE_NO_WARNINGS
#include "header.h"

int validirajImePrezime(const char* unos) {
	for (int i = 0; unos[i] != '\0' && unos[i] != '\n'; ++i)
		if (!isalpha((unsigned char)unos[i])) return 0;
	return 1;
}

int validirajID(const char* unos) {
	for (int i = 0; unos[i] != '\0' && unos[i] != '\n'; ++i)
		if (!isdigit((unsigned char)unos[i])) return 0;
	return 1;
}

// Učitavanje članova iz datoteke u dinamički niz pokazivača
CLAN** ucitajClanoveIzDatoteke(FILE* file, int* brojClanova) {
	CLAN** clanovi = NULL;
	*brojClanova = 0;
	char ime[100], prezime[100];
	int id;
	fseek(file, 0, SEEK_SET);
	while (fscanf(file, "%99s %99s %d", ime, prezime, &id) == 3) {
		CLAN* novi = malloc(sizeof(CLAN));
		novi->ime = malloc(strlen(ime) + 1);
		novi->prezime = malloc(strlen(prezime) + 1);
		strcpy(novi->ime, ime);
		strcpy(novi->prezime, prezime);
		novi->id = id;
		clanovi = realloc(clanovi, (*brojClanova + 1) * sizeof(CLAN*));
		clanovi[*brojClanova] = novi;
		(*brojClanova)++;
	}
	return clanovi;
}

// Spremanje članova u datoteku
void spremiClanoveUDatoteku(FILE* file, CLAN** clanovi, int brojClanova) {
	freopen(NULL, "w", file); // Očisti datoteku
	for (int i = 0; i < brojClanova; i++)
		fprintf(file, "%s %s %d\n", clanovi[i]->ime, clanovi[i]->prezime, clanovi[i]->id);
}

// Oslobađanje memorije svih članova
void oslobodiClanove(CLAN** clanovi, int brojClanova) {
	for (int i = 0; i < brojClanova; i++) {
		free(clanovi[i]->ime);
		free(clanovi[i]->prezime);
		free(clanovi[i]);
	}
	free(clanovi);
}

// Dodavanje člana
void dodajClana(CLAN*** clanovi, int* brojClanova) {
	char buffer[100];
	CLAN* novi = malloc(sizeof(CLAN));
	// Ime
	do {
		printf("Ime: ");
		fgets(buffer, sizeof(buffer), stdin);
		buffer[strcspn(buffer, "\n")] = 0;
		if (!validirajImePrezime(buffer) || strlen(buffer) == 0)
			printf("Ime smije sadrzavati samo slova. Pokusaj ponovno.\n");
		else {
			novi->ime = malloc(strlen(buffer) + 1);
			strcpy(novi->ime, buffer);
		}
	} while (!novi->ime);

	// Prezime
	do {
		printf("Prezime: ");
		fgets(buffer, sizeof(buffer), stdin);
		buffer[strcspn(buffer, "\n")] = 0;
		if (!validirajImePrezime(buffer) || strlen(buffer) == 0)
			printf("Prezime smije sadrzavati samo slova. Pokusaj ponovno.\n");
		else {
			novi->prezime = malloc(strlen(buffer) + 1);
			strcpy(novi->prezime, buffer);
		}
	} while (!novi->prezime);

	// ID
	int duplicateID;
	do {
		duplicateID = 0;
		printf("ID: ");
		fgets(buffer, sizeof(buffer), stdin);
		buffer[strcspn(buffer, "\n")] = 0;
		if (!validirajID(buffer) || strlen(buffer) == 0) {
			printf("ID smije sadržavati samo znamenke. Pokusaj ponovno.\n");
			continue;
		}
		novi->id = atoi(buffer);
		for (int i = 0; i < *brojClanova; i++) {
			if ((*clanovi)[i]->id == novi->id) {
				printf("Clan s unesenim ID-om vec postoji. Odaberi drugi ID.\n");
				duplicateID = 1;
				break;
			}
		}
	} while (duplicateID || !validirajID(buffer) || strlen(buffer) == 0);

	*clanovi = realloc(*clanovi, (*brojClanova + 1) * sizeof(CLAN*));
	(*clanovi)[*brojClanova] = novi;
	(*brojClanova)++;
	printf("Clan je uspjesno dodan.\n");
}

// Brisanje člana
void izbrisiClana(CLAN*** clanovi, int* brojClanova, int id) {
	int found = 0;
	for (int i = 0; i < *brojClanova; i++) {
		if ((*clanovi)[i]->id == id) {
			free((*clanovi)[i]->ime);
			free((*clanovi)[i]->prezime);
			free((*clanovi)[i]);
			for (int j = i; j < *brojClanova - 1; j++)
				(*clanovi)[j] = (*clanovi)[j + 1];
			(*brojClanova)--;
			*clanovi = realloc(*clanovi, (*brojClanova) * sizeof(CLAN*));
			printf("Clan je izbrisan.\n");
			found = 1;
			break;
		}
	}
	if (!found) printf("Clan nije pronaden.\n");
}

// Ispis svih članova
void ispisClanova(CLAN** clanovi, int brojClanova) {
	printf("Clanovi teretane:\n");
	for (int i = 0; i < brojClanova; i++)
		printf("Ime: %s %s\nID: %d\n\n", clanovi[i]->ime, clanovi[i]->prezime, clanovi[i]->id);
}

// Usporedba po imenu
static int usporedbaClanova(const void* a, const void* b) {
	CLAN* const* ca = (CLAN* const*)a;
	CLAN* const* cb = (CLAN* const*)b;
	return strcmp((*ca)->ime, (*cb)->ime);
}

// Usporedba po prezimenu
static int usporedbaClanovaPoPrezimenu(const void* a, const void* b) {
	CLAN* const* ca = (CLAN* const*)a;
	CLAN* const* cb = (CLAN* const*)b;
	return strcmp((*ca)->prezime, (*cb)->prezime);
}

// Sortirani ispis po imenu
void ispisSortiranihClanovaPoImenu(CLAN** clanovi, int brojClanova) {
	if (brojClanova == 0) {
		printf("Nema clanova za ispis.\n");
		return;
	}
	CLAN** kopija = calloc(brojClanova, sizeof(CLAN*));
	for (int i = 0; i < brojClanova; i++) kopija[i] = clanovi[i];
	qsort(kopija, brojClanova, sizeof(CLAN*), usporedbaClanova);
	printf("Sortirani clanovi teretane po imenu:\n");
	for (int i = 0; i < brojClanova; i++)
		printf("Ime: %s %s\nID: %d\n\n", kopija[i]->ime, kopija[i]->prezime, kopija[i]->id);
	free(kopija);
}

// Sortirani ispis po prezimenu
void ispisSortiranihClanovaPoPrezimenu(CLAN** clanovi, int brojClanova) {
	if (brojClanova == 0) {
		printf("Nema clanova za ispis.\n");
		return;
	}
	CLAN** kopija = calloc(brojClanova, sizeof(CLAN*));
	for (int i = 0; i < brojClanova; i++) kopija[i] = clanovi[i];
	qsort(kopija, brojClanova, sizeof(CLAN*), usporedbaClanovaPoPrezimenu);
	printf("Sortirani clanovi teretane po prezimenu:\n");
	for (int i = 0; i < brojClanova; i++)
		printf("Ime: %s %s\nID: %d\n\n", kopija[i]->ime, kopija[i]->prezime, kopija[i]->id);
	free(kopija);
}

// Pretraga člana po ID-u
void pretrazivanje(CLAN** clanovi, int brojClanova, int id) {
	for (int i = 0; i < brojClanova; i++) {
		if (clanovi[i]->id == id) {
			printf("Clan je pronaden:\nIme: %s %s\nID: %d\n", clanovi[i]->ime, clanovi[i]->prezime, clanovi[i]->id);
			return;
		}
	}
	printf("Clan nije pronaden.\n");
}

// Najveći ID
void najveciID(CLAN** clanovi, int brojClanova) {
	if (brojClanova == 0) {
		printf("Nema pronadenih clanova.\n");
		return;
	}
	int max = clanovi[0]->id, idx = 0;
	for (int i = 1; i < brojClanova; i++)
		if (clanovi[i]->id > max) { max = clanovi[i]->id; idx = i; }
	printf("Clan koji ima najveci ID:\nIme: %s\nPrezime: %s\nID: %d\n", clanovi[idx]->ime, clanovi[idx]->prezime, clanovi[idx]->id);
}

main.c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include "header.h"

typedef enum {
	DODAJ_CLANA = 1,
	IZBRISI_CLANA,
	ISPISI_CLANOVE,
	SORTIRAJ_PO_IMENU,
	SORTIRAJ_PO_PREZIMENU,
	PRETRAZI_PO_ID,
	NAJVECI_ID,
	IZLAZ
} IzbornikOpcija;

int main(void) {
	int id = 0;
	int brojClanova = 0;
	IzbornikOpcija odabir;
	FILE* file = fopen("gym.txt", "a+");
	if (!file) {
		perror("Greska pri otvaranju datoteke");
		return 1;
	}
	CLAN** clanovi = ucitajClanoveIzDatoteke(file, &brojClanova);
	fclose(file);

	do {
		printf("\n");
		printf("========================================\n");
		printf("|         GYM MANAGEMENT SYSTEM        |\n");
		printf("========================================\n");
		printf("| 1 - Dodaj clana                      |\n");
		printf("| 2 - Izbrisi clana                    |\n");
		printf("| 3 - Ispisi sve clanove               |\n");
		printf("| 4 - Sortiraj po imenu                |\n");
		printf("| 5 - Sortiraj po prezimenu            |\n");
		printf("| 6 - Pretrazi po ID-u                 |\n");
		printf("| 7 - Prikazi clana s najvecim ID-em   |\n");
		printf("| 8 - Izlaz                            |\n");
		printf("========================================\n");
		printf("Odabir: ");
		if (scanf("%d", (int*)&odabir) != 1) {
			printf("Neispravan unos!\n");
			while (fgetc(stdin) != '\n');
			continue;
		}
		while (getchar() != '\n' && !feof(stdin));

		switch (odabir) {
		case DODAJ_CLANA:
			dodajClana(&clanovi, &brojClanova);
			break;
		case IZBRISI_CLANA:
			printf("Unesi ID clana za brisanje: ");
			if (scanf("%d", &id) == 1) {
				while (getchar() != '\n' && !feof(stdin));
				izbrisiClana(&clanovi, &brojClanova, id);
			}
			else {
				printf("Neispravan unos!\n");
				while (getchar() != '\n' && !feof(stdin));
			}
			break;
		case ISPISI_CLANOVE:
			ispisClanova(clanovi, brojClanova);
			break;
		case SORTIRAJ_PO_IMENU:
			ispisSortiranihClanovaPoImenu(clanovi, brojClanova);
			break;
		case SORTIRAJ_PO_PREZIMENU:
			ispisSortiranihClanovaPoPrezimenu(clanovi, brojClanova);
			break;
		case PRETRAZI_PO_ID:
			printf("Unesi ID clana za pretragu: ");
			if (scanf("%d", &id) == 1) {
				while (getchar() != '\n' && !feof(stdin));
				pretrazivanje(clanovi, brojClanova, id);
			}
			else {
				printf("Neispravan unos!\n");
				while (getchar() != '\n' && !feof(stdin));
			}
			break;
		case NAJVECI_ID:
			najveciID(clanovi, brojClanova);
			break;
		case IZLAZ:
			printf("Hvala na koristenju programa! Dovidjenja.\n");
			break;
		default:
			printf("Nepostojeca opcija!\n");
			break;
		}
	} while (odabir != IZLAZ);

	// Spremi sve članove u datoteku na izlazu
	file = fopen("gym.txt", "w");
	if (!file) {
		perror("Greska pri otvaranju datoteke za spremanje");
	}
	else {
		spremiClanoveUDatoteku(file, clanovi, brojClanova);
		fclose(file);
	}
	oslobodiClanove(clanovi, brojClanova);

	return 0;
}

